---
title: "MPX Ready Reckoners"
format: html
editor: visual
---

```{r}
library(tidyverse)
library(boot)
library(cowplot)


natsal=read.delim("../UKDA-7799-tab/tab/eul_natsal_2010_for_archive.tab")

#natsalCOVIDwave2=read.delim("../UKDA-8865-tab/tab/natsal_covid_wave_2_archive.tab")

```

```{r }

#| eval: false

colnames(natsal)

#het5yrs no. of het. sex partners, last 5 years

head(natsal$het5yrs)

#9999 == not answered
table(natsal$sam5yrs)

#table(natsal$overlp5y)
table(natsal$het1yr)

#9999 == not answered
table(natsal$sam1yr)


table(natsal$hhsize)
#9995: at least one if hhsize is not answered

summary(natsal$dage)

```

```{r}
natsal %>%
  filter(het1yr<900) %>%
  group_by(dage) %>%
  summarise(meantot = mean(het1yr)) %>%
  ggplot(aes(x=dage,y=meantot)) +
  geom_point()+
  theme_minimal_grid()


natsal %>%
  filter(het1yr<900) %>%
  group_by(dage) %>%
  summarise(meantot = mean(total_wt)) %>%
  ggplot(aes(x=dage,y=meantot)) +
  geom_point()+
  ylab('Weighted Number of Contacts')+
  xlab('Age of Participant')+
  theme_minimal_grid()



```

```{r}

summary(natsal$total_wt)
natsal %>%
  select(sin2,total_wt,dage,hhsize,het1yr,sam1yr) -> RRdata

attackrate = c(0.12,0.12,0.013) # from Packer et al

RRdata %>%
  filter(sam1yr <100 & het1yr<100 & hhsize<100) %>%
  mutate(indR = attackrate[1]*sam1yr + attackrate[2]*het1yr + attackrate[3]*hhsize) -> RRdata


mult1=1
rind=cbind(RRdata$indR,RRdata$total_wt)

myweightedmean=function(DD,ix)
{
  return(sum(DD[ix,2]*DD[ix,1]^2)/sum(DD[ix,1]*DD[ix,2]))
}

myboot=boot(rind,statistic=myweightedmean,R=500)
mult1*mean(myboot$t)
myinterval = 0.95
bci=boot.ci(myboot,type="basic",conf=myinterval)
mult1*bci$basic[1,4:5]
mult1*range(myboot$t)

sum(rind[,2]*rind[,1]^2)/sum(rind[,1]) # calculate individual R

summary(RRdata$indR)



```

```{r}

RRdata %>%
  group_by(dage) %>%
  summarise(meantot = mean(indR)) %>%
  ggplot(aes(x=dage,y=meantot)) +
  geom_point()


RRdata %>%
  group_by(sam1yr) %>%
  summarise(meantot = mean(indR)) %>%
  ggplot(aes(x=sam1yr,y=meantot)) +
  geom_point()

RRdata %>%
  ggplot(aes(x=indR)) + 
  geom_histogram()

```

```{r}

# generate dataset of only MSMs (more than 0 same sex contacts in 1 year)

RRdata %>%
  filter(sam1yr>0) -> MSM 


rind2=cbind(MSM$indR,MSM$total_wt)
myboot=boot(rind2,statistic=myweightedmean,R=500)
mult1*mean(myboot$t)
mult1*range(myboot$t)

sum(MSM$sam1yr)/sum(MSM$sam1yr+MSM$het1yr)

MSM %>% 
  mutate(totalcontacts = het1yr+sam1yr) %>% 
  mutate(propsame = sam1yr/totalcontacts)->MSM

head(MSM)
MSM %>% 
  ggplot(aes(x=propsame))+
  geom_histogram()

MSM %>% 
  summary(propsame)

MSM %>% 
  ggplot(aes(x=totalcontacts,y=propsame))+
  geom_point()

MSM %>% 
  group_by(sam1yr) %>% 
  summarise(meanR = mean(indR)) %>% 
  ggplot(aes(x=sam1yr,y=meanR))+
  geom_point()




```

```{r}

# Bootstrap code. 

totalhet = sum(RRdata$het1yr)
totalsame = sum(RRdata$sam1yr)
num1=length(RRdata$het1yr)
mult1=1 #use this later if we need to scale contacts
deltaX = 1:100
Rpop=matrix(NA,nrow=length(deltaX),ncol=3)
for(i in deltaX)
{
  #calculate number of contacts to reduce
  contactra = RRdata$het1yr
  totalcontacts=sum(contactra)
  
  #distribute them randomly across all people (not accounting for weights here!)
  r1=runif(length(contactra),min=0,max=contactra)
  r1=(1-i/100)*totalcontacts*r1/sum(r1)
  
  new1=c(round(r1[1]),diff(round(cumsum(r1))))

  RRdata2 = RRdata
  RRdata2$het1yr = new1
  
  #recalculate individual R numbers
  RRdata2 %>%
    filter(sam1yr <100 & het1yr<100 & hhsize<100) %>%
    mutate(indR = attackrate[1]*sam1yr + attackrate[2]*het1yr + attackrate[3]*hhsize) -> RRdata2
  
  #extract individual R numbers
  rind=cbind(RRdata2$indR,RRdata2$total_wt)
  myboot=boot(rind,statistic=myweightedmean,R=2000)
  Rpop[i,1] = mult1*mean(myboot$t)
  Rpop[i,2:3] = mult1*range(myboot$t)
}

deltaX = 1:100
RpopSAME=matrix(NA,nrow=length(deltaX),ncol=3)
for(i in deltaX)
{
  #calculate number of contacts to reduce
  contactra = RRdata$sam1yr
  totalcontacts=sum(contactra)
  
  #distribute them randomly across all people (not accounting for weights here!)
  r1=runif(length(contactra),min=0,max=contactra)
  r1=(1-i/100)*totalcontacts*r1/sum(r1)
  
  new1=c(round(r1[1]),diff(round(cumsum(r1))))
  
  RRdata2 = RRdata
  RRdata2$sam1yr = new1
  
  #recalculate individual R numbers
  RRdata2 %>%
    filter(sam1yr <100 & het1yr<100 & hhsize<100) %>%
    mutate(indR = attackrate[1]*sam1yr + attackrate[2]*het1yr + attackrate[3]*hhsize) -> RRdata2
  
  #extract individual R numbers
  rind=cbind(RRdata2$indR,RRdata2$total_wt)
  myboot=boot(rind,statistic=myweightedmean,R=500)
  RpopSAME[i,1] = mult1*mean(myboot$t)
  RpopSAME[i,2:3] = mult1*range(myboot$t)
}

#plot
mycols2=c(rgb(0,0.5,1,0.5),rgb(0,0.8,0.8,0.5),rgb(0,0.8,0,0.5),rgb(0.8,0.0,0.0,0.5),rgb(1,1,0,0.5),rgb(0.3,0.3,0.3,0.6))

par(mar=c(5,5,1,1),mfrow=c(1,1))
x=deltaX
y2=rev(Rpop[,3]); y1=rev(Rpop[,2]) 
plot(x,Rpop[,1],ylim=range(Rpop[,],0),pch=19,xlab="",col="white",
     ylab=expression(paste("Reproduction number, ",R[t])),cex.lab=1.5,cex.axis=1.3,cex=1.0)

mtext("% active sexual contacts",side=1,line=2.5,cex=1.3)

grid()

abline(h=1,col="grey",lwd=3)

polygon(c(x,rev(x)),c(y2,rev(y1)),col=mycols2[6],border=NA)


y2=rev(RpopSAME[,3]); y1=rev(RpopSAME[,2])
polygon(c(x,rev(x)),c(y2,rev(y1)),col=mycols2[5],border=NA)

#test
# mycontacts = round(runif(10,min=0,max=100))
# mycontacts
# totalcontacts=sum(mycontacts)
# 
# r1=runif(10,min=0,max=mycontacts)
# r1=0.5*totalcontacts*r1/sum(r1)
# new1=c(round(r1[1]),diff(round(cumsum(r1))))


```

```{r}

deltaX = 1:100
RpopMSM=matrix(NA,nrow=length(deltaX),ncol=3)
numreps=10
for(i in deltaX)
{
  #calculate number of contacts to reduce
  contactra = MSM$sam1yr
  totalcontacts=sum(contactra)
  
  contactrahet = MSM$het1yr
  totalcontactshet=sum(contactrahet)
  
  rind=c()
  
  for(rx in 1:numreps) # loop over repetitions
  {
    #distribute them randomly across all people (not accounting for weights here!)
    r1=runif(length(contactra),min=0,max=contactra)
    r1=(1-i/100)*totalcontacts*r1/sum(r1)
  
    new1=c(round(r1[1]),diff(round(cumsum(r1))))
    #new1 = c(round((1-i/100)*contactra[1]),round(diff(cumsum(((1-i/100)*contactra)))))
  
    MSM2 = MSM
    MSM2$sam1yr = new1
    
    r1=runif(length(contactrahet),min=0,max=contactrahet)
    r1=(1-i/100)*totalcontactshet*r1/sum(r1)
    
    new1=c(round(r1[1]),diff(round(cumsum(r1))))
    
    MSM2$het1yr = new1
  
    #recalculate individual R numbers
    MSM2 %>%
      filter(sam1yr <100 & het1yr<100 & hhsize<100) %>%
      mutate(indR = attackrate[1]*sam1yr + attackrate[2]*het1yr + attackrate[3]*hhsize) -> MSM2
  
    #extract individual R numbers
    rind1=cbind(MSM2$indR,MSM2$total_wt)
    
    rind=rbind(rind,rind1)  
  }
  
  myboot=boot(rind,statistic=myweightedmean,R=2000)
  bci=boot.ci(myboot,type="perc",conf=myinterval)
  
  RpopMSM[i,1] = mult1*mean(myboot$t)
  #RpopMSM[i,2:3] = mult1*range(myboot$t)
  RpopMSM[i,2:3] = mult1*bci$percent[1,4:5]
}

mycols2=c(rgb(0,0.5,1,0.5),rgb(0,0.8,0.8,0.5),rgb(0,0.8,0,0.5),rgb(0.8,0.0,0.0,0.5),rgb(1,1,0,0.5),rgb(0.3,0.3,0.3,0.6))

par(mar=c(5,5,1,1),mfrow=c(1,1))
x=deltaX
y2=rev(RpopMSM[,3]); y1=rev(RpopMSM[,2]) 

plot(x,rev(RpopMSM[,1]),ylim=range(RpopMSM[,],0),pch=19,xlab="",col="red",
     ylab=expression(paste("Reproduction number, ",R[t])),cex.lab=1.5,cex.axis=1.3,cex=1.0)

lines(x,rev(RpopMSM[,2]))
lines(x,rev(RpopMSM[,3]))

mtext("% active same sex sexual contacts",side=1,line=2.5,cex=1.3)

grid()

abline(h=1,col="grey",lwd=3)

polygon(c(x,rev(x)),c(y2,rev(y1)),col=mycols2[6],border=NA)


```

# Vaccination

```{r}
 
# setup

RRdata %>% # select out anomalous values (e.g. 999) contacts 
  filter(sam1yr <100 & het1yr<100 & hhsize<100) %>%
  mutate(vaccineeffect = 1) %>%
  mutate(indR = vaccineeffect*attackrate[1]*sam1yr + 
                vaccineeffect*attackrate[2]*het1yr + 
                vaccineeffect*attackrate[3]*hhsize) -> RRdata

## calculate individual Rs 

MSM %>%
  filter(sam1yr <100 & het1yr<100 & hhsize<100) %>%
  mutate(vaccineeffect = 1) %>% #this is whether the vaccine is effective in this person
  mutate(indR = vaccineeffect*attackrate[1]*sam1yr + 
                vaccineeffect*attackrate[2]*het1yr + 
                vaccineeffect*attackrate[3]*hhsize) -> MSM



rind2=cbind(MSM$indR,MSM$total_wt)

myboot=boot(rind2,statistic=myweightedmean,R=500)
print(paste("R = ",mult1*mean(myboot$t))) # overall R
print(mult1*range(myboot$t)) # range of R 

Clade2SAR = c(0.12,0.12,0.013) # from Packer et al



# This is the function that generates the vaccination R estimate dataset.
CalcRNumbers = function(contacts = MSM,
                        SameSexSAR = 0.12,
                        HeteroSAR = 0.12,
                        HouseholdSAR = 0.013,
                        VE=0.8,
                        numreps = 50){
  
  attackrate = c(SameSexSAR,HeteroSAR,HouseholdSAR) 
  # contacts holds the NATSAL3 datasets 
  
  MSM = contacts
  mult1=1 # what is this? it's set to 1 and doesn't do anything.
  deltaX = seq(100,0,-2) # loop (backwards over deltaX)
  numMSM = length(MSM$total_wt)

  RpopMSM_target=matrix(NA,nrow=length(deltaX),ncol=3)
  RpopMSM_random=matrix(NA,nrow=length(deltaX),ncol=3)
  j=1
  #Attack rate defaults to Clade 2 SAR from Packer et al. 
  #VE defaults to 0.8
  
  for(i in deltaX)
  {
    MSM$vaccineeffect=1 # set VE to 1
    num2vac = round(numMSM*i/100)
    #print(paste("num to vaccinate=",num2vac))
    
    
    rind_rand=c() # reset matrix
    rind_target=c()
    
    MSM$vaccineeffect=1
    MSM %>%
      mutate(indR = vaccineeffect*attackrate[1]*sam1yr + 
               vaccineeffect*attackrate[2]*het1yr + 
               vaccineeffect*attackrate[3]*hhsize) -> MSM
    
    for(rx in 1:numreps) # number of repetitions 
    {
      
      #Random Vaccination
      MSM3 = MSM # reset the data frame to original for every rep
      
      rand1 = sample(1:numMSM, num2vac, replace=F) # select the people to randomly vaccinate
      
      MSM3$vaccineeffect[rand1] = 1 - VE
      
      MSM3 %>%
        mutate(indR = vaccineeffect*attackrate[1]*sam1yr + 
                 vaccineeffect*attackrate[2]*het1yr + 
                 vaccineeffect*attackrate[3]*hhsize) -> MSM3 # recalculate R, into indR
      
      
      #extract individual R numbers
      
      rind1=cbind(MSM3$indR,MSM3$total_wt)
      rind_rand=rbind(rind_rand,rind1) 
      
      #  Preferentially vaccination select high-contact individuals first
      
      rand2 = sample(1:numMSM, num2vac, replace=F, 
                     prob = (MSM$totalcontacts+1)/sum(MSM$totalcontacts+numMSM))
      
      MSM2=MSM # reset MSM matrix
      MSM2$vaccineeffect[rand2] = 1 - VE
      
      MSM2 %>%
        mutate(indR = vaccineeffect*attackrate[1]*sam1yr + 
                 vaccineeffect*attackrate[2]*het1yr + 
                 vaccineeffect*attackrate[3]*hhsize) -> MSM2
      
      rind1=cbind(MSM2$indR,MSM2$total_wt)
      rind_target=rbind(rind_target,rind1) 
    }
    
    myboot=boot(rind_rand,statistic=myweightedmean,R=1000)
    #bci=boot.ci(myboot,type="perc",conf=myinterval)
    bci = quantile(myboot$t,probs = c(0.025,0.975))
    RpopMSM_random[j,1] = mult1*mean(myboot$t)
#   RpopMSM_random[j,2:3] = mult1*bci$percent[1,4:5]
    RpopMSM_random[j,2:3] = mult1*as.numeric(bci)

    myboot=boot(rind_target,statistic=myweightedmean,R=1000)
    bci=boot.ci(myboot,type="perc",conf=myinterval)

    RpopMSM_target[j,1] = mult1*mean(myboot$t)
    RpopMSM_target[j,2:3] = mult1*bci$percent[1,4:5]
    
    j=j+1
  }
  
  bind_rows(
    as_tibble(RpopMSM_random)|>
      rename(Mean = V1, Lower = V2, Upper = V3) |> 
      add_column("Vaccinated"=deltaX,Type = 'Random'), 
    as_tibble(RpopMSM_target)|>
      rename(Mean = V1, Lower = V2, Upper = V3) |> 
      add_column("Vaccinated"=deltaX,Type = 'Targetted')  
  ) -> RMSM.df
  
  return(RMSM.df)
}





```

```{r}
#refactor the above code. DO NOT TOUCH ABOVE

CalcRNumbersVax2 = function(contacts = MSM,
                        SameSexSAR = 0.12,
                        HeteroSAR = 0.12,
                        HouseholdSAR = 0.013,
                        VE=0.8,
                        numreps = 10){
  
  attackrate = c(SameSexSAR,HeteroSAR,HouseholdSAR) 
  # contacts holds the NATSAL3 datasets 
  MSM = contacts # this can be all types of contact. 
  #mult1=1 # what is this? it's set to 1 and doesn't do anything.
  VaxCover = seq(0,100,2) # generate sequence to model over vaccine coverage 
  numMSM = length(MSM$total_wt) # number of individuals

  RpopMSM_target=matrix(NA,nrow=length(deltaX),ncol=3) # set up holding matrices
  RpopMSM_random=matrix(NA,nrow=length(deltaX),ncol=3)
  j=1
  #Attack rate defaults to Clade 2 SAR from Packer et al. 
  #VE defaults to 0.8
  
  as_tibble(VaxCover)|>rename(VaxCover = value) |>
  
  #for(i in deltaX)
  {
    MSM$vaccineeffect=1 # set VE to 1
    VaxCover$Number2Vax = round(numMSM*VaxCover/100)
#    print(paste("num to vaccinate=",num2vac))
    
    
    rind_rand=c() # reset matrix
    rind_target=c()
    
    random_index = sample(1:numMSM, 20, replace=F) 
    preferential_index = sample(1:numMSM, num2vac, replace=F, 
                     prob = (MSM$totalcontacts+1)/sum(MSM$totalcontacts+numMSM))
    
    MSM$VERandom[random_index] = 1 - VE
    MSM$VEPref[preferential_index] = 1 - VE
    
    MSM |>
      mutate(indRRandom = 
               VERandom*attackrate[1]*sam1yr + 
               VERandom*attackrate[2]*het1yr + 
               VERandom*attackrate[3]*hhsize)   |>
      mutate(indRPref = 
               VEPRef*attackrate[1]*sam1yr + 
               VEPRef*attackrate[2]*het1yr + 
               VEPRef*attackrate[3]*hhsize)-> MSM

    
    
    #    Number2Vax=20
#    MSM |> 
#      slice_sample(n=Number2Vax,replace=F,.preserve = TRUE) # we don't want slice because it removes the other rows. we want an equivalent that only modifies VE (indR) for selected rows. 
    
```

```{r}
    for(rx in 1:numreps) # number of repetitions 
    {
      
      #Random Vaccination
      MSM3 = MSM # reset the data frame to original for every rep
      
      # select the people to randomly vaccinate
      
      MSM3$vaccineeffect[rand1] = 1 - VE
      
      MSM3 %>%
        mutate(indR = vaccineeffect*attackrate[1]*sam1yr + 
                 vaccineeffect*attackrate[2]*het1yr + 
                 vaccineeffect*attackrate[3]*hhsize) -> MSM3 # recalculate R, into indR
      
      
      #extract individual R numbers
      
      rind1=cbind(MSM3$indR,MSM3$total_wt)
      rind_rand=rbind(rind_rand,rind1) 
      
      #  Preferentially vaccination select high-contact individuals first
      
      rand2 = sample(1:numMSM, num2vac, replace=F, 
                     prob = (MSM$totalcontacts+1)/sum(MSM$totalcontacts+numMSM))
      
      MSM2=MSM # reset MSM matrix
      MSM2$vaccineeffect[rand2] = 1 - VE
      
      MSM2 %>%
        mutate(indR = vaccineeffect*attackrate[1]*sam1yr + 
                 vaccineeffect*attackrate[2]*het1yr + 
                 vaccineeffect*attackrate[3]*hhsize) -> MSM2
      
      rind1=cbind(MSM2$indR,MSM2$total_wt)
      rind_target=rbind(rind_target,rind1) 
    }
    
    myboot=boot(rind_rand,statistic=myweightedmean,R=1000)
    bci=boot.ci(myboot,type="perc",conf=myinterval)
    
    RpopMSM_random[j,1] = mult1*mean(myboot$t)
    RpopMSM_random[j,2:3] = mult1*bci$percent[1,4:5]
    

    myboot=boot(rind_target,statistic=myweightedmean,R=1000)
    bci=boot.ci(myboot,type="perc",conf=myinterval)

    RpopMSM_target[j,1] = mult1*mean(myboot$t)
    RpopMSM_target[j,2:3] = mult1*bci$percent[1,4:5]
    
    j=j+1
  }
  
  bind_rows(
    as_tibble(RpopMSM_random)|>
      rename(Mean = V1, Lower = V2, Upper = V3) |> 
      add_column("Vaccinated"=deltaX,Type = 'Random'), 
    as_tibble(RpopMSM_target)|>
      rename(Mean = V1, Lower = V2, Upper = V3) |> 
      add_column("Vaccinated"=deltaX,Type = 'Targetted')  
  ) -> RMSM.df
  
  return(RMSM.df)
}



```

# Plot vaccine reckoner

```{r}

#

ExtractVaxBands = function(dataDF = RMSMCIIb.df){ 
  dataDF |> 
    slice_min(abs(1-Mean),n=3, by = 'Type') %>% # extract R closest to 1
    select(Vaccinated,Type) %>% 
    group_by(Type) %>% 
    mutate(Lower=min(Vaccinated),Upper=max(Vaccinated)) %>% 
    filter(Vaccinated == median(Vaccinated))->VaxBands
  return(VaxBands)
}


GGPlotVaxRibbons = function(dataDF = RMSMCIIb.df){
  VaxBands = ExtractVaxBands(dataDF)
  dataDF|>
    ggplot(aes(x=Vaccinated,ymin = Lower,ymax=Upper,fill=Type))+
    geom_ribbon(alpha = 0.4) +
    geom_hline(yintercept=1,linetype='dotted')+
    geom_rect(data=VaxBands %>% filter(Type=='Random'),aes(xmin=Lower,xmax=Upper,ymin=0,ymax=Inf), colour = 'grey',alpha=0.1)+
    geom_rect(data=VaxBands %>% filter(Type=='Targetted'),aes(xmin=Lower,xmax=Upper,ymin=0,ymax=Inf),colour = 'grey',alpha=0.1)+
    ylab('R in individuals with same sex partnerships')+
    xlab('% Vaccinated')+
    theme_bw()->p
  p
  return(p)
}
#ExtractVaxBands(RMSMCIb.df)

```

```{r}
# Do the calculations

RMSMCIIb.df = CalcRNumbers(numreps=50)

RMSMCIb.df = CalcRNumbers(HouseholdSAR = Clade2SAR[3]*10,numreps=50)

RMSMCI20 = CalcRNumbers(HouseholdSAR = 0.2,numreps=50)

RMSMCI40 = CalcRNumbers(HouseholdSAR = 0.4,numreps=50)

RMSMCIb50 = CalcRNumbers(HouseholdSAR = 0.5,numreps = 50)

```

```{r}
library(patchwork)

GGPlotVaxRibbons(RMSMCIIb.df) -> Clade2Plot

GGPlotVaxRibbons(RMSMCIb.df) -> CladeIbPlot


GGPlotVaxRibbons(RMSMCI20) -> CladeIb20Plot

GGPlotVaxRibbons(RMSMCI40) -> CladeIb40Plot
  
GGPlotVaxRibbons(RMSMCIb50) -> CladeIb50Plot

Clade2Plot + ggtitle('Clade IIb') -> p1
CladeIbPlot + ggtitle('Clade Ib = Household SAR = 13%') -> p2
CladeIb20Plot + ggtitle('Clade Ib Household SAR = 20%') -> p3
CladeIb40Plot + ggtitle('Clade Ib Household SAR = 40%') -> p4

CladeIb50Plot + ggtitle('Clade Ib Household SAR = 50%') -> p5


p1+theme(legend.position = "none")+ylim(0,2.25)+
p2+theme(legend.position = "none")+ylim(0,2.25)+
p3+theme(legend.position = "none")+ylim(0,2.25)+
p4+theme(legend.position = "none")+ylim(0,2.25)+
p5+ylim(0,2.25)  

```

```{r}
library(purrr)
library(furrr)
library(boot)
HHSAR = dplyr::as_tibble(c(0.013,0.13,0.2,0.4,0.5))|>rename(HouseholdSAR = value)

plan(multisession, workers = 6)
options = furrr_options(seed=TRUE)

HHSAR|>
  mutate(tmp = future_map(HouseholdSAR, ~CalcRNumbers(HouseholdSAR = .x),.options = options)) |>
    unnest(tmp)-> RibbonPlotData

HHSAR|>
  mutate(tmp = future_map(HouseholdSAR, ~CalcRNumbers(HouseholdSAR = .x)|>ExtractVaxBands(),.options = options)) |>
    unnest(tmp)-> RibbonPlotDataVaxBoxes



RibbonPlotData |>
  #unnest(tmp) %>% 
  ggplot(aes(x=Vaccinated))+
  geom_ribbon(aes(ymin = Lower,ymax=Upper,fill=Type),alpha = 0.4)+   
  geom_hline(yintercept=1,linetype='dotted')+
  geom_rect(data=RibbonPlotDataVaxBoxes |> filter(Type=='Random'),aes(xmin=Lower,xmax=Upper,ymin=0,ymax=Inf,fill=Type), colour = 'grey',alpha=0.1)+
  geom_rect(data=RibbonPlotDataVaxBoxes |> filter(Type=='Targetted'),aes(xmin=Lower,xmax=Upper,ymin=0,ymax=Inf,fill=Type),colour = 'grey',alpha=0.1)+
  facet_grid(.~HouseholdSAR,labeller = 'label_both')+
  xlab('Proportion Vaccinated (%)')+
  ylab('Population Reproduction Number')+
  theme_bw()->panel_plots

panel_plots
```

```{r}

#now run it for vax thresholds
HHSAR = as_tibble(seq(0.0,0.5,0.02))|>rename(HouseholdSAR = value)

HHSAR|>
  mutate(tmp = future_map(HouseholdSAR, 
                          ~CalcRNumbers(HouseholdSAR = .x,numreps = 50)|>ExtractVaxBands(),
                          .options = options,
                          .progress = TRUE)) |>
    unnest(tmp)-> VaxPlotData
```

```{r}
VaxPlotData |>
  ggplot(aes(x=HouseholdSAR,ymin=Lower,ymax=Upper,fill=Type))+
  geom_ribbon(alpha=0.4,colour='grey')+
  theme_bw()+
  xlab('Household SAR')+
  ylab('Vaccination Threshold (%)') -> threshold_plot

threshold_plot
```

```{r}

panel_plots / threshold_plot & theme(axis.title = element_text(size = 10)) ->combined_plot

combined_plot

A = 6
GoldenRatio = (1+sqrt(5))/2

ggsave(plot = combined_plot,filename = 'VaxThresholdPlot.png',device = 'png',width = A*GoldenRatio,height = A)

```

# Reduced VE

```{r}

ReducedVE = 0.2

HHSAR|>
  mutate(tmp = future_map(HouseholdSAR, 
                          ~CalcRNumbers(HouseholdSAR = .x,
                                        numreps = 50,
                                        VE = ReducedVE),
                          .options = options,
                          .progress = TRUE)) ->tmp_df


tmp_df|>
  unnest(tmp)->RibbonPlotDataVE0_2

tmp_df|>
  rowwise()|>
  mutate(tmp2 = list(tmp|>ExtractVaxBands()))|>
  select(HouseholdSAR,tmp2)|>
  unnest(tmp2)->RibbonPlotDataVaxBoxesVE0_2_ALT
```

```{r}


# old fashioned way - more costly. 
HHSAR|>
  mutate(tmp = future_map(HouseholdSAR, 
                          ~CalcRNumbers(HouseholdSAR = .x,
                                        numreps=50,
                                        VE = ReducedVE)|>ExtractVaxBands(),
                          .options = options,
                          .progress = TRUE)) |>
    unnest(tmp)-> RibbonPlotDataVaxBoxesVE0_2




RibbonPlotDataVE0_2 |>
  #unnest(tmp) %>% 
  ggplot(aes(x=Vaccinated))+
  geom_ribbon(aes(ymin = Lower,ymax=Upper,fill=Type),alpha = 0.4)+   
  geom_hline(yintercept=1,linetype='dotted')+
  geom_rect(data=RibbonPlotDataVaxBoxesVE0_2_ALT |> filter(Type=='Random'),aes(xmin=Lower,xmax=Upper,ymin=0,ymax=Inf,fill=Type), colour = 'grey',alpha=0.1)+
  geom_rect(data=RibbonPlotDataVaxBoxesVE0_2_ALT |> filter(Type=='Targetted'),aes(xmin=Lower,xmax=Upper,ymin=0,ymax=Inf,fill=Type),colour = 'grey',alpha=0.1)+
  facet_grid(.~HouseholdSAR,labeller = 'label_both')+
  xlab('Proportion Vaccinated (%)')+
  ylab('Population Reproduction Number')+
  theme_bw()->panel_plots_reducedVE

panel_plots_reducedVE




```

```{r}

HHSARSweep = as_tibble(seq(0.0,0.5,0.02))|>rename(HouseholdSAR = value)

HHSARSweep|>
  mutate(tmp = future_map(HouseholdSAR, 
                          ~CalcRNumbers(HouseholdSAR = .x,
                                        numreps = 100,
                                        VE = ReducedVE)|>ExtractVaxBands(),
                          .options = options,
                          .progress = TRUE),) |>
    unnest(tmp)-> VaxPlotData_VE_02

VaxPlotDataVE_02 |>
  ggplot(aes(x=HouseholdSAR,ymin=Lower,ymax=Upper,fill=Type))+
  geom_ribbon(alpha=0.4,colour='grey')+
  theme_bw()+
  xlab('Household SAR')+
  ylab('Vaccination Threshold (%)') -> threshold_plot

```
